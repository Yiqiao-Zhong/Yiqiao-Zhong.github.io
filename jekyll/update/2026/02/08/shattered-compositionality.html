<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Shattered compositionality: how transformers learn arithmetic rules | Advancing Interpretability of Deep Learning</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Shattered compositionality: how transformers learn arithmetic rules" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve had a recent paper with students where we made quite intriguing findings on transformers’ learning dynamics." />
<meta property="og:description" content="I’ve had a recent paper with students where we made quite intriguing findings on transformers’ learning dynamics." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2026/02/08/shattered-compositionality.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2026/02/08/shattered-compositionality.html" />
<meta property="og:site_name" content="Advancing Interpretability of Deep Learning" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-02-08T18:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Shattered compositionality: how transformers learn arithmetic rules" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-02-08T18:00:00-06:00","datePublished":"2026-02-08T18:00:00-06:00","description":"I’ve had a recent paper with students where we made quite intriguing findings on transformers’ learning dynamics.","headline":"Shattered compositionality: how transformers learn arithmetic rules","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2026/02/08/shattered-compositionality.html"},"url":"http://localhost:4000/jekyll/update/2026/02/08/shattered-compositionality.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Advancing Interpretability of Deep Learning" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Advancing Interpretability of Deep Learning</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About me</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Shattered compositionality: how transformers learn arithmetic rules</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2026-02-08T18:00:00-06:00" itemprop="datePublished">Feb 8, 2026
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I’ve had a recent <a href="https://arxiv.org/abs/2601.22510">paper</a> with students where we made quite intriguing findings on transformers’ learning dynamics.</p>

<p><strong>A lurking nightmare</strong>. Given the undisputed performance of recent LLMs such as GPT-5 and Claude Code, many of us have forgotten the early days of ChatGPT when it frequently made <a href="https://www.reddit.com/r/ChatGPT/comments/13nm89a/when_i_ask_chatgpt_multiply_the_following_numbers/">errors</a> in basic arithmetic such as multiplication. Yet, the training recipe for pretraining, which is <strong>autoregressive training</strong> (aka next-token prediction) on transformers, stays largely the same. What has caused persistent defects in the current models will likely pass on to future successors. Of course, better training data and tool use have reduced hallucination for now, but who knows what awaits us when this technology is applied to many new domains on a large scale? A recent <a href="https://www.nature.com/articles/s41586-025-09937-5">Nature paper</a> on emergent misalignment shows the disconcerting risks.</p>

<p>A lingering puzzle of LLMs remains unsolved—</p>

<h2 id="how-do-models-build-their-own-rules">How do models build their own rules?</h2>

<p>Here is a recurring question that has fueled endless debates since three years ago:</p>

<p><em>Are LLMs rule learners or pattern matching machines?</em></p>

<p>AI proponents contend that LLMs are capable of any knowledge work, while skeptics argue that LLMs are merely stochastic parrots that mix texts from training data. The gap between these two opposing narratives does not narrow if the lingering puzzle remains unsolved—how do these models figure out rules from data that differ from human’s expectation? While AI alignment develops practical techniques to address this mismatch, we have poor understanding about <em>what</em> causes the mismatch and <em>how</em> it emerges from autoregressive training.</p>

<h2 id="dissecting-learning-dynamics-on-synthetic-experiments">Dissecting learning dynamics on synthetic experiments</h2>

<p>Now that it has become impossible for most people to pretrain an LLM, we decided to train a small transformer from scratch on synthetic data. There are two big advantages of such synthetic experiments: first, we can track the model’s learning behavior using comprehensive evaluation metrics; second, we have full understanding and control over the training data. The synthetic experiments are not the end point of our study; instead they are means to a bigger end: understanding how learning dynamics induces a model’s peculiar behaviors. Of course, this doesn’t capture everything about real LLMs—but it lets us isolate one mechanism very cleanly.</p>

<p>One of the simple arithmetic tasks we studied in the paper is to solve a 4-operand addition. Our training data are text strings of the format $a + b + c + d = e$ where \(a,b,c,d\) are integers sampled uniformly from 0 to 999 and \(e\) is the correct result. Each string is a training example, tokenized character-by-character as one input sequence to the transformer. We adapted a simple training <a href="https://github.com/karpathy/nanoGPT">implementation</a> to our setting. Since the model scale is very small, each complete run of the training cost little on Google Colab.</p>

<p>What do we expect from autoregressive training on our synthetic data? Let’s consider an example:</p>

\[\begin{equation}
(\text{plain format})~~~~~~349 + 102 + 382 + 907 = 1740.
\end{equation}\]

<p>When a model is given the context (characters) preceding the first output digit 1, it needs to figure out the thousands-place digit by using all hundreds-place digits (namely 3, 1, 3, 9) before the equality, together with possible carry from lower digit places. Next, in order to correctly predict the hundreds-place digit 7 of the output digit, the model needs to compute a modulus-10 calculation together with possible carry from lower digit places. But this awkward calculation order is not what we learn in elementary school! It is much easier for start with units, the lowest digit place.</p>

<p>Let’s consider a human-friendly format where we reverse the order in the output integer.</p>

\[\begin{equation}
(\text{reverse format})~~~~~~349 + 102 + 382 + 907 = 0471.
\end{equation}\]

<p>Now, the first digit in the output integer is 0, which is the modulus-10 result of \(9+2+2+7\). We don’t need to worry about carry as it is the unit place. Next, predicting the tens-place \(4\) requires calculating the modulus-10 result of \(4+0+8+0\) and carry from the unit place. By this point, we usually have kept our calculation for the unit place in our scratch paper, so it is easy to proceed with this order.</p>

<p>There are reasons to believe that the reverse format is easier to learn not only for humans but also for models, as advocated by this <a href="https://arxiv.org/abs/2307.03381">paper</a>, because learning individual digits amounts to a composition of modulus-10 operations and carry in a linear progression.</p>

<h2 id="the-puzzle-of-reverse-learning-order">The puzzle of reverse learning order</h2>

<p>This expectation proves to be wrong. After running experiments separately with both output formats, we’ve found that transformers “insist” on learning from the thousands-place digit regardless of the output format!</p>

<p style="text-align: center;"><img src="/assets/images/shattered-compositionality/addition-learning-order.png" alt="Addition-learning-order" width="800" /></p>

<p>The digit-wise error rates (comparing the model’s prediction with the correct answer) in the figure indicate that there is still a persistent linear learning order, but in the opposite direction to human’s rules. The setting with reverse output format that is supposed to be easier to learn, actually causes the model to learn slower: convergence takes much longer in the right plot, and the plateaus in the evolution of error rates suggest undesired loss landscapes.</p>

<p>As we became baffled by this puzzle, an examination of the error distribution showed another striking phenemenon.</p>

<p style="text-align: center;"><img src="/assets/images/shattered-compositionality/gaussian-errors.png" alt="Error-distribution" width="800" /></p>

<p>We computed the difference between the correct integer and the model’s predicted integer \(\hat{e} - e\) and treated this error as a whole instead of four separate digits. The figure shows that the errors are approximately Gaussian distributed, and the spread narrows as training proceeds. It tells us that the model behaves like an approximation algorithm—first figuring out the rough range of the output integer with a wide error distribution, then gradually refining the prediction with narrowing error distribution. Rather than learning the underlying algebraic rules of addition, the model appears to solve the task using an approximate, analytical strategy.</p>

<p>Can scaling fix this non-human learning order? We’ve tested the addition task with larger models and conducted a finetuning experiment using Pythia-1B. All experiments showed the consistent reverse learning order. We came to the conclusion that transformers are not rule learners, unless being fed with carefully designed reasoning data.</p>

<h2 id="correlational-matching-drives-learning-dynamics">Correlational matching drives learning dynamics</h2>

<p>What is the cause of the counterintuitive learning dynamics? We turned to pattern matching as a plausible explanation. But a deeper understanding requires a definition of what we mean by the “pattern” or “signal” the model learns throughout training. I was motivated by the mutual information (MI) metrics in an earlier <a href="https://arxiv.org/abs/2305.18654">paper</a>, so we considered the following metrics as a measurement of correlational structure from training data (recall that MI is zero if two random variables are independent). Let \(a=a_1a_2a_3\) be the digit representation of first input integer and \(e=e_0e_1e_2e_3\) be the output integer. According to our sampling of training data, all digits \(a_i\) and $e_j$$ can be viewed as random variables.</p>

<ul>
  <li>Mutual information \(I(a_1; e_0)\): how much information the hundreds-place digit \(a_1\) provides for predicting the thousands-place digit \(e_0\)</li>
  <li>Conditional mutual information \(I(a_i; e_i \mid c_{i-1})\): how much information the input digit provides for predicting the output digit at the same digit place, <em>conditional</em> on the carry to the higher digit.</li>
</ul>

<p>A positive MI means there is <strong>learnable signal</strong> in the training data, which can be captured by the (stochastic) gradient descent as we train a model. For example, a large \(a_1\) is more likely to yield a large \(e_0\), so this correlational structure offers a signal for the model to catch. Interestingly, \(I(a_i; e_i)\) itself is zero, whereas conditioning on the carry at a higher digit \(c_{i-1}\) yields positive MI \(I(a_i; e_i \mid c_{i-1})\). This provides a plausibility for the reverse learning order—a model starts with the signal in \(I(a_1; e_0)\) and proceed to lower digits since conditioning on acquired ``skills’’ at higher digits provides learnable signals.</p>

<p style="text-align: center;"><img src="/assets/images/shattered-compositionality/mutual-information.png" alt="Mutual-information" width="600" /></p>

<p>We devised similar MI metrics to measure a model’s predictive behavior throughout training, and compared the evoluation of a model’s MI metrics against those calculated from the training data. The figure shows that critical drops in training loss match closely with phase transitions in the mutual information metrics. As we examined these plots, it became clear that correlational matching offers a much more convincing explanation for the model’s learning behavior—learning is driven less by discovering explicit rules and more by exploiting whatever statistical dependencies are easiest to capture early on.</p>

<h2 id="shattered-compositionality-causes-brittle-performance">Shattered compositionality causes brittle performance</h2>

<p>For arithmetic tasks, pattern matching appears to be a winning narrative—but what are the consequences of this unexpected learning order? In our experiments, the errors eventually go down to approximately zero if we training long enough.</p>

<p>We continued our investigation into several other synthetic tasks and expanded to a few LLM experiments as well. We identified a few additional “warning messages”:</p>

<ul>
  <li><strong>Unpredictable learning behavior.</strong> Besides the reverse learning order, a transformer may learn arithmetic in multiple orders concurrently. This parallel learning mechanism often results in “skill competition”, where learning one pattern interferes negatively with learning another.</li>
  <li><strong>Unintended mixing errors.</strong> A model generates unexpected mixing errors where a part of model’s output is repeated or swapped with another part.</li>
  <li><strong>Deteriorating performance under distribution shift</strong>. Correlational matching soon becomes a liability when the test examples are from a different distribution. Even across many high-performing LLMs, slight twists of reasoning benchmarks yield much worse accuracy.</li>
</ul>

<p>Once learning is driven by correlations rather than explicit rules, compositional structure becomes fragile, and failures begin to follow recognizable patterns.</p>

<div class="note">
<strong>Shattered compositionality:</strong> Parallel or reversed skill learning yields a fragile composition, where tensions between skill acquisition can trigger mixing errors under distribution shift.
</div>

<h2 id="final-thoughts">Final thoughts</h2>

<p>Our paper echoes some recent findings on compositionality in LLMs.</p>

<ul>
  <li><em>Parallel mechanisms.</em> In the Anthropic’s <a href="https://transformer-circuits.pub/2025/attribution-graphs/biology.html">blog</a> on the biology of an LLM, they discover the existence of multiple pathways within the model for solving complex tasks, some of which are in synergy and some of which are in competition.</li>
  <li><em>Bag of Heuristics.</em> A recent <a href="https://arxiv.org/abs/2410.21272">paper</a> that argues that LLMs solve compositional tasks with a bag of heuristics instead of using coherent rules.</li>
</ul>

<p>To improve the robustness and transparency of LLMs, we need more evaluation metrics. Standard benchmarking is a good idea, but we can’t predict how LLMs may perform on out-of-distribution data or in a new domain. Our analysis of synthetic tasks is a first step toward building more robust and safer AI systems in the future.</p>

  </div><a class="u-url" href="/jekyll/update/2026/02/08/shattered-compositionality.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Advancing Interpretability of Deep Learning</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Advancing Interpretability of Deep Learning</li><li><a class="u-email" href="mailto:yiqiao.zhong@wisc.edu">yiqiao.zhong@wisc.edu</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Yiqiao-Zhong"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Yiqiao-Zhong</span></a></li><li><a href="https://www.twitter.com/yiqiao_zhong"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">yiqiao_zhong</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Can we understand the inner workings of black-box models? The goal of the blogs is to explore structures and analyze empirical phenoemna by scientific experiments on deep learning. </p>
      </div>
    </div>

  </div>

</footer>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
    

  </body>

</html>
